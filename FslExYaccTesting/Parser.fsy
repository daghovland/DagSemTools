%{
open System
open IriTools
open AlcTableau
open AlcTableau.ALC
%}

// The start token becomes a parser function in the compiled code:
%start start

// Regular tokens
%token HELLO
%token CLASS
%token SUBCLASSOF
%token EQUIVALENTTO
%token SOME
%token ONLY
%token AND
%token OR
%token NOT
%token LPAREN
%token RPAREN
%token COMMA
%token INVERSE
%token ANNOTATIONS
%token PREFIX
%token ONTOLOGY
%token IMPORT
%token THAT
%token LT
%token GT
%token <string> FULLIRI
%token <string> ABBREVIATETEDIRI
%token <string> PREFIXEDIRI
%token SCHEME 

// Misc tokens
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < AlcTableau.ALC.Concept > start
%type < IriTools.IriReference > Iri

%left SOME ONLY 
%left AND
%left OR

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  
start: description EOF { $1 }

description:
    | description OR conjunction { AlcTableau.ALC.Disjunction($1, $3) }
    | conjunction { $1 }
    
    
conjunction:
    | conjunction AND primary { AlcTableau.ALC.Conjunction($1, $3) }
    | primary { $1 }

restriction:
    | objectPropertyExpression SOME primary { AlcTableau.ALC.Existential($1, $3) }
    | objectPropertyExpression ONLY primary { AlcTableau.ALC.Universal($1, $3) }

primary:
    | NOT primary { AlcTableau.ALC.Negation($2) }
    | restriction { $1 }
    | Iri { AlcTableau.ALC.ConceptName($1) }
    | LPAREN description RPAREN { $2 }

classFrame: CLASS Iri classExpressionList { $3 (AlcTableau.ALC.ConceptName $2) }

classExpressionList:  
    classExpression { $1 }
    | classExpression classExpressionList { fun superclass -> Seq.append ($1 superclass) ($2 superclass) }

classExpression:
    SUBCLASSOF descriptionAnnotatedList { fun superclass ->  Seq.map (fun subclass -> AlcTableau.ALC.Inclusion(subclass, superclass)) $2 }
    | EQUIVALENTTO descriptionAnnotatedList { fun superclass ->  Seq.map (fun subclass -> AlcTableau.ALC.Equivalence(subclass, superclass)) $2 }

descriptionAnnotatedList:
    | description {[$1]}
    | description COMMA descriptionAnnotatedList { $1 :: $3 }

objectPropertyExpression:
    | Iri { AlcTableau.ALC.Role($1)}
    | INVERSE Iri { failwith "Inverse not supported"  }

Iri: 
    | LT FULLIRI GT { $2 }
    | ABBREVIATETEDIRI { $1 }
    | PREFIXEDIRI { $1 } 

